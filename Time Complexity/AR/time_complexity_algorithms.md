
# Time Complexity in Algorithms

في علوم الكمبيوتر، الـ **Time Complexity** هو مقياس يعبر عن كم من الوقت يستغرقه الخوارزم لتشغيله بناءً على حجم المدخلات. الهدف من قياس التعقيد الزمني هو فهم أداء الخوارزم في حالات مختلفة.

### 1. **O(1)** - **Constant Time**
تعني **O(1)** تعقيد ثابت، أي أن الوقت الذي يستغرقه الكود لا يعتمد على حجم المدخلات. مهما كانت البيانات، الوقت ثابت.

#### مثال كود:
```python
def get_first_element(lst):
    return lst[0]
```

في هذا المثال، الوصول إلى العنصر الأول من القائمة يستغرق وقتًا ثابتًا.

#### حالات استخدام:

* الوصول إلى أول عنصر في قائمة.
* استرجاع قيمة من قاموس باستخدام مفتاح.

---

### 2. **O(n)** - **Linear Time**

تعني **O(n)** تعقيد خطي، أي أن الوقت يزداد بشكل مباشر مع زيادة حجم المدخلات. إذا كانت المدخلات أكبر، الوقت الذي يستغرقه الكود سيكون أكبر بنفس المقدار.

#### مثال كود:

```python
def print_elements(lst):
    for item in lst:
        print(item)
```

في هذا المثال، نحن نقوم بالمرور عبر كل عنصر في القائمة، وبالتالي الوقت يعتمد على عدد العناصر.

#### حالات استخدام:

* التكرار على كل العناصر في قائمة أو مجموعة.
* فحص جميع الحروف في نص معين.

---

### 3. **O(n²)** - **Quadratic Time**

تعني **O(n²)** تعقيد تربيعي. الوقت يزداد بمعدل مربع عدد المدخلات. عادة ما يحدث ذلك عندما يكون لدينا عمليات متداخلة على كل زوج من العناصر.

#### مثال كود:

```python
def bubble_sort(lst):
    for i in range(len(lst)):
        for j in range(0, len(lst)-i-1):
            if lst[j] > lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
```

في هذا المثال، لدينا حلقتان متداخلتان تقومان بمقارنة وتبادل العناصر في القائمة، مما يؤدي إلى تعقيد زمني تربيعي **O(n²)**.

#### حالات استخدام:

* خوارزميات الفرز مثل **Bubble Sort** و **Selection Sort**.
* مقارنة جميع العناصر في مصفوفة مع بعضها البعض.

---

### 4. **O(n log n)** - **Linearithmic Time**

تعني **O(n log n)** تعقيد خطي لوغاريتمي. الوقت يزداد بمعدل أكبر من **O(n)** ولكن أقل من **O(n²)**. عادة ما يحدث هذا في الخوارزميات التي تقسم البيانات إلى جزئين.

#### مثال كود:

```python
def merge_sort(lst):
    if len(lst) > 1:
        mid = len(lst) // 2
        left_half = lst[:mid]
        right_half = lst[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                lst[k] = left_half[i]
                i += 1
            else:
                lst[k] = right_half[j]
                j += 1
            k += 1
```

في هذا المثال، الخوارزمية تقوم بتقسيم القائمة إلى جزئين ثم تقوم بدمجهم بطريقة مرتبة. كل تقسيم يأخذ وقتًا **O(log n)**، ومع وجود **n** تقسيمات، يصبح الزمن الكلي **O(n log n)**.

#### حالات استخدام:

* خوارزميات الفرز مثل **Merge Sort** و **Quick Sort**.
* بعض العمليات التي تقوم بتقسيم المدخلات إلى أجزاء متساوية.

---

### 5. **O(2^n)** - **Exponential Time**

تعني **O(2^n)** تعقيد أسي، حيث الوقت يزداد بشكل سريع جداً مع زيادة حجم المدخلات. عادة ما يحدث هذا في الخوارزميات التي تجرّب كل الاحتمالات الممكنة.

#### مثال كود:

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

في هذا المثال، الخوارزمية تقوم بحساب سلسلة فيبوناتشي باستخدام التكرار العكسي. العدد الكبير من الاستدعاءات يؤدي إلى تعقيد أسي **O(2^n)**.

#### حالات استخدام:

* بعض خوارزميات القوة الغاشمة **Brute Force**.
* خوارزميات البحث في الأشجار أو الرسوم البيانية باستخدام التكرار العكسي.

---

### 6. **O(log n)** - **Logarithmic Time**

تعني **O(log n)** تعقيد لوغاريتمي حيث الوقت يزداد بشكل أبطأ بكثير مقارنة بـ **O(n)** أو **O(n²)**. يحدث هذا في الخوارزميات التي تقوم بتقسيم المدخلات بشكل تدريجي إلى أجزاء أصغر.

#### مثال كود:

```python
def binary_search(lst, target):
    left, right = 0, len(lst) - 1
    while left <= right:
        mid = (left + right) // 2
        if lst[mid] == target:
            return mid
        elif lst[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

في هذا المثال، الخوارزمية تقوم بالبحث عن عنصر في قائمة مرتبة باستخدام **البحث الثنائي**، حيث يتم تقليص مساحة البحث إلى النصف في كل خطوة. وبالتالي، يكون التعقيد الزمني **O(log n)**.

#### حالات استخدام:

* البحث الثنائي في قوائم مرتبة.
* بعض خوارزميات البحث في الأشجار.

---

### كيفية اختيار n في الكود؟

الناتج **n** هو حجم المدخلات التي تتعامل معها الخوارزمية، مثل:

* عدد العناصر في قائمة.
* عدد الحروف في نص.
* عدد النقاط في مجموعة بيانات.

#### مثال:

* إذا كان لديك قائمة من الأرقام (مثلاً: 10 أرقام)، فإن **n** هو 10.
* إذا كان لديك نص طوله 50 حرفًا، فإن **n** هو 50.

---

### خاتمة:

الفهم الجيد للـ **Time Complexity** يساعد في تحسين أداء الخوارزميات والكود بشكل عام. عند كتابة كود، حاول دائمًا التفكير في كيفية تأثير حجم المدخلات على الأداء واختيار الخوارزمية الأنسب لحالة الاستخدام.
